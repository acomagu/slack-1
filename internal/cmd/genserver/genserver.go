package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"github.com/pkg/errors"
)

var stockResponses = map[string]string{
	"channels.info": "StockChannelResponse",
}

func main() {
	if err := _main(); err != nil {
		log.Printf("%s", err)
		os.Exit(1)
	}
}

type stringList []string

func (s *stringList) UnmarshalJSON(data []byte) error {
	if data[0] == '"' {
		var v string
		if err := json.Unmarshal(data, &v); err != nil {
			return errors.Wrap(err, `failed to unmarshal string for stringList`)
		}
		*s = []string{v}
		return nil
	}

	var v []string
	if err := json.Unmarshal(data, &v); err != nil {
		return errors.Wrap(err, `failed to unmarshal string list for stringList`)
	}
	*s = v
	return nil
}

type Endpoint struct {
	file       string
	methodName string
	Group      string     `json:"group,omitempty"`
	Name       string     `json:"name"` // e.g. "chat.PostMessage"
	JSON       stringList `json:"json"`
	Args       []Argument `json:"args,omitempty"`
	ReturnType stringList `json:"return,omitempty"`
	SkipToken  bool       `json:"skip_token,omitempty"`
}

type Argument struct {
	Name      string `json:"name"`
	Type      string `json:"type"`
	Required  bool   `json:"required,omitempty"`
	Default   string `json:"default,omitempty"`
	QueryName string `json:"query_name,omitempty"`
	Comment   string `json:"comment,omitempty"`
}

func camelit(s string) string {
	var buf bytes.Buffer

	var upnext bool
	for i, r := range s {
		if i == 0 || upnext {
			buf.WriteRune(unicode.ToUpper(r))
			upnext = false
			continue
		}

		if r == '.' || r == '_' {
			upnext = true
			continue
		}

		buf.WriteRune(r)
	}
	return buf.String()
}

func _main() error {
	var endpoints []*Endpoint

	fh, err := os.Open("endpoints.json")
	if err != nil {
		return errors.Wrap(err, `failed to open endpoints.json`)
	}
	defer fh.Close()

	if err := json.NewDecoder(fh).Decode(&endpoints); err != nil {
		return errors.Wrap(err, `failed to decode endpoints.json`)
	}

	sort.Slice(endpoints, func(i, j int) bool {
		return strings.Compare(endpoints[i].Name, endpoints[j].Name) < 0
	})

	group := map[string][]*Endpoint{}
	for _, endpoint := range endpoints {
		i := strings.LastIndexByte(endpoint.Name, '.')
		endpoint.file = filepath.Join("server", strings.Replace(endpoint.Name[:i], ".", "_", -1)+"_gen.go")
		if len(endpoint.Group) == 0 {
			endpoint.Group = camelit(endpoint.Name[:i])
		}
		endpoint.methodName = camelit(endpoint.Name[i+1:])
		group[endpoint.file] = append(group[endpoint.file], endpoint)
	}

	if err := generateServerFile(endpoints); err != nil {
		return errors.Wrap(err, `failed to generate server file`)
	}

	if err := generateMockServerFile(endpoints); err != nil {
		return errors.Wrap(err, `failed to generate mock server file`)
	}

	/*
		for fn, endpoints := range group {
			if err := generateServiceDetailsFile(fn, endpoints); err != nil {
				return errors.Wrapf(err, `failed to generate file %s`, fn)
			}
		}
	*/
	return nil
}

func generateServerFile(endpoints []*Endpoint) error {
	var buf bytes.Buffer
	buf.WriteString("package server")
	buf.WriteString("\n\n// Auto-generated by internal/cmd/genserver/genserver.go. DO NOT EDIT!")
	buf.WriteString("\n\nimport (")
	for _, pkg := range []string{"net/http", "sync"} {
		fmt.Fprintf(&buf, "\n%s", strconv.Quote(pkg))
	}
	buf.WriteString("\n")
	for _, pkg := range []string{} {
		fmt.Fprintf(&buf, "\n%s", strconv.Quote(pkg))
	}
	buf.WriteString("\n)")

	fmt.Fprintf(&buf, "\n\ntype Server struct {")
	fmt.Fprintf(&buf, "\nhandlers map[string]http.Handler")
	fmt.Fprintf(&buf, "\nmuHandlers sync.RWMutex")
	fmt.Fprintf(&buf, "\n}") // end type Server

	fmt.Fprintf(&buf, "\n\nfunc unimplemented(w http.ResponseWriter, r *http.Request) {")
	fmt.Fprintf(&buf, "\nhttp.Error(w, `method ` + r.URL.Path[1:] + ` is unimplemented on this server`, http.StatusBadRequest)")
	fmt.Fprintf(&buf, "\n}") // end func Unimplemented

	fmt.Fprintf(&buf, "\n\nfunc New() *Server {")
	fmt.Fprintf(&buf, "\nreturn &Server{")
	fmt.Fprintf(&buf, "\nhandlers: map[string]http.Handler{")
	for _, endpoint := range endpoints {
		fmt.Fprintf(&buf, "\n%s: http.HandlerFunc(unimplemented),", strconv.Quote(endpoint.Name))
	}
	fmt.Fprintf(&buf, "\n},") // end of map
	fmt.Fprintf(&buf, "\n}")  // end of Server
	fmt.Fprintf(&buf, "\n}")  // end of New

	fmt.Fprintf(&buf, "\n\n// Handle sets the http.Handler for the given slack method.")
	fmt.Fprintf(&buf, "\nfunc (s *Server) Handle(method string, h http.Handler) {")
	fmt.Fprintf(&buf, "\ns.muHandlers.Lock()")
	fmt.Fprintf(&buf, "\ndefer s.muHandlers.Unlock()")
	fmt.Fprintf(&buf, "\ns.handlers[method] = h")
	fmt.Fprintf(&buf, "\n}") // end of func Handler

	fmt.Fprintf(&buf, "\n\nfunc (s *Server) GetHandler(method string) (http.Handler, bool) {")
	fmt.Fprintf(&buf, "\ns.muHandlers.RLock()")
	fmt.Fprintf(&buf, "\ndefer s.muHandlers.RUnlock()")
	fmt.Fprintf(&buf, "\nh, ok := s.handlers[method]")
	fmt.Fprintf(&buf, "\nreturn h, ok")
	fmt.Fprintf(&buf, "\n}") // end of GetHandler

	fmt.Fprintf(&buf, "\nfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {")
	fmt.Fprintf(&buf, "\nh, ok := s.GetHandler(r.URL.Path[1:])")
	fmt.Fprintf(&buf, "\nif !ok {")
	fmt.Fprintf(&buf, "\nhttp.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)")
	fmt.Fprintf(&buf, "\nreturn")
	fmt.Fprintf(&buf, "\n}") // end if
	fmt.Fprintf(&buf, "\nh.ServeHTTP(w, r)")
	fmt.Fprintf(&buf, "\n}") // end func ServeHTTP

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("%s", buf.Bytes())
		return errors.Wrap(err, `failed to format code`)
	}

	file := filepath.Join("server", "server.go")
	fh, err := os.Create(file)
	if err != nil {
		return errors.Wrapf(err, `failed to open file %s for writing`, file)
	}
	defer fh.Close()

	fh.Write(formatted)
	return nil
}

func generateMockServerFile(endpoints []*Endpoint) error {
	var buf bytes.Buffer
	buf.WriteString("package mockserver")
	buf.WriteString("\n\n// Auto-generated by internal/cmd/genserver/genserver.go. DO NOT EDIT!")
	buf.WriteString("\n\nimport (")
	for _, pkg := range []string{"bytes", "encoding/json", "net/http"} {
		fmt.Fprintf(&buf, "\n%s", strconv.Quote(pkg))
	}
	buf.WriteString("\n")
	for _, pkg := range []string{"github.com/lestrrat/go-slack", "github.com/lestrrat/go-slack/server"} {
		fmt.Fprintf(&buf, "\n%s", strconv.Quote(pkg))
	}
	buf.WriteString("\n)")

	fmt.Fprintf(&buf, "\n\nfunc New() *server.Server {")
	fmt.Fprintf(&buf, "\ns := server.New()")
	for _, endpoint := range endpoints {
		fmt.Fprintf(&buf, "\ns.Handle(%s, http.HandlerFunc(Handle%s%s))", strconv.Quote(endpoint.Name), endpoint.Group, endpoint.methodName)
	}
	fmt.Fprintf(&buf, "\nreturn s")
	fmt.Fprintf(&buf, "\n}")  // end of New

	for _, endpoint := range endpoints {
		fmt.Fprintf(&buf, "\n\n// Handle%s%s is the default handler method for the Slack %s API", endpoint.Group, endpoint.methodName, endpoint.Name)
		fmt.Fprintf(&buf, "\nfunc Handle%s%s(w http.ResponseWriter, r *http.Request) {", endpoint.Group, endpoint.methodName)
		fmt.Fprintf(&buf, "\nvar c slack.%s%sCall", endpoint.Group, endpoint.methodName)
		fmt.Fprintf(&buf, "\nif err := c.FromValues(r.Form); err != nil {")
		fmt.Fprintf(&buf, "\nhttp.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)")
		fmt.Fprintf(&buf, "\nreturn")
		fmt.Fprintf(&buf, "\n}") // end if err := c.FormValues

		fmt.Fprintf(&buf, "\nvar buf bytes.Buffer")
		fmt.Fprintf(&buf, "\nif err := json.NewEncoder(&buf).Encode(")
		stockResponse, ok := stockResponses[endpoint.Name]
		if ok {
			fmt.Fprintf(&buf, stockResponse)
		} else {
			fmt.Fprintf(&buf, "slack.SlackResponse{OK: true}")
		}
		fmt.Fprintf(&buf, "); err != nil {")
		fmt.Fprintf(&buf, "\nhttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)")
		fmt.Fprintf(&buf, "\n}") // end if err := json.NewEncoder
		fmt.Fprintf(&buf, "\nw.Header().Set(`Content-Type`, `application/json; charset=utf-8`)")
		fmt.Fprintf(&buf, "\nw.WriteHeader(http.StatusOK)")
		fmt.Fprintf(&buf, "\nbuf.WriteTo(w)")

		fmt.Fprintf(&buf, "\n}") // end func Handle%s%s
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("%s", buf.Bytes())
		return errors.Wrap(err, `failed to format code`)
	}

	file := filepath.Join("server", "mockserver", "mockserver.go")
	fh, err := os.Create(file)
	if err != nil {
		return errors.Wrapf(err, `failed to open file %s for writing`, file)
	}
	defer fh.Close()

	fh.Write(formatted)
	return nil
}
